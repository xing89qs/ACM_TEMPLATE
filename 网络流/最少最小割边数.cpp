
/*

最小割性质：最小割边一定满流，满流的不一定是最小割边。

*/

/*

1.建边：每条边权 w = w * (MAXE + 1) + 1 （因为加上 1 之后跑出来的最大流必定是边数最小的）；

2.得到的最大流为 max_flow / (MAXE + 1) （因为即使所有的边都算上，也只是多了 E 条边，除以 (E + 1) 后完全不影响结果）。

3.最小的割边数是 max_flow % (E + 1) ，即把全部的 1 算上也只有 E，对 (E + 1) 取余后就是最小的边数。

注：另一种“跑一次网络流以后修改满流边容量为 1，其他边为 INF ”的算法是假算法。原因：最小割边一定满流，满流的不一定是最小割边。

*/

void buildGraph()
{
    while(m--)  //m为边数
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        addEdge(u,v,w*(MAXE+1)+1);
    }
}

void solve()
{
    buildGraph();
    printf("%d\n",maxFlow()%(MAXE+1));  //求出的结果就是最少最小割边数
    //printf("%d\n",SAP(s,t)%(MAXE+1));
}
